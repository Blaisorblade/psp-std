L9   526    package
L9   534    scala
L11  541    <nls>
L11  541    import
L11  548    scala
L11  553    .
L11  554    collection
L11  564    .
L11  565    {
L11  567    mutable
L11  574    ,
L11  576    immutable
L11  585    ,
L11  587    generic
L11  594    ,
L11  596    SortedSetLike
L11  609    ,
L11  611    AbstractSet
L11  623    }
L12  625    <nl>
L12  625    import
L12  632    java
L12  636    .
L12  637    lang
L12  641    .
L12  642    reflect
L12  649    .
L12  650    {
L12  652    Modifier
L12  660    ,
L12  662    Method
L12  669    =>
L12  672    JMethod
L12  679    ,
L12  681    Field
L12  687    =>
L12  690    JField
L12  697    }
L13  699    <nl>
L13  699    import
L13  706    scala
L13  711    .
L13  712    reflect
L13  719    .
L13  720    NameTransformer
L13  735    .
L13  736    _
L14  738    <nl>
L14  738    import
L14  745    scala
L14  750    .
L14  751    util
L14  755    .
L14  756    matching
L14  764    .
L14  765    Regex
L53  1929   <nls>
L53  1929   @
L53  1930   SerialVersionUID
L53  1946   (
L53  1947   8476000850333817230
L53  1967   )
L54  1969   <nl>
L54  1969   abstract
L54  1978   class
L54  1984   Enumeration
L54  1996   (
L54  1997   initial
L54  2004   :
L54  2006   Int
L54  2009   )
L54  2011   extends
L54  2019   Serializable
L54  2032   {
L55  2036   thisenum
L55  2045   =>
L57  2051   def
L57  2055   this
L57  2059   (
L57  2060   )
L57  2062   =
L57  2064   this
L57  2068   (
L57  2069   0
L57  2070   )
L61  2203   <nls>
L61  2205   protected
L61  2215   def
L61  2219   readResolve
L61  2230   (
L61  2231   )
L61  2232   :
L61  2234   AnyRef
L61  2241   =
L61  2243   thisenum
L61  2251   .
L61  2252   getClass
L61  2260   .
L61  2261   getField
L61  2269   (
L61  2270   MODULE_INSTANCE_NAME
L61  2290   )
L61  2291   .
L61  2292   get
L61  2295   (
L61  2296   null
L61  2300   )
L65  2345   <nls>
L65  2347   override
L65  2356   def
L65  2360   toString
L65  2369   =
L66  2375   (
L66  2376   (
L66  2377   getClass
L66  2385   .
L66  2386   getName
L66  2394   stripSuffix
L66  2406   MODULE_SUFFIX_STRING
L66  2427   split
L66  2433   46
L66  2436   )
L66  2437   .
L66  2438   last
L66  2443   split
L67  2456   Regex
L67  2461   .
L67  2462   quote
L67  2467   (
L67  2468   NAME_JOIN_STRING
L67  2484   )
L67  2485   )
L67  2486   .
L67  2487   last
L71  2583   <nls>
L71  2585   private
L71  2593   val
L71  2597   vmap
L71  2601   :
L71  2603   mutable
L71  2610   .
L71  2611   Map
L71  2614   [
L71  2615   Int
L71  2618   ,
L71  2620   Value
L71  2625   ]
L71  2627   =
L71  2629   new
L71  2633   mutable
L71  2640   .
L71  2641   HashMap
L74  2709   <nls>
L74  2711   @
L74  2712   transient
L74  2722   private
L74  2730   var
L74  2734   vset
L74  2738   :
L74  2740   ValueSet
L74  2749   =
L74  2751   null
L75  2756   <nl>
L75  2758   @
L75  2759   transient
L75  2769   @
L75  2770   volatile
L75  2779   private
L75  2787   var
L75  2791   vsetDefined
L75  2803   =
L75  2805   false
L79  2896   <nls>
L79  2898   private
L79  2906   val
L79  2910   nmap
L79  2914   :
L79  2916   mutable
L79  2923   .
L79  2924   Map
L79  2927   [
L79  2928   Int
L79  2931   ,
L79  2933   String
L79  2939   ]
L79  2941   =
L79  2943   new
L79  2947   mutable
L79  2954   .
L79  2955   HashMap
L83  3017   <nls>
L83  3019   def
L83  3023   values
L83  3029   :
L83  3031   ValueSet
L83  3040   =
L83  3042   {
L84  3048   if
L84  3051   (
L84  3052   !
L84  3053   vsetDefined
L84  3064   )
L84  3066   {
L85  3074   vset
L85  3079   =
L85  3081   (
L85  3082   ValueSet
L85  3090   .
L85  3091   newBuilder
L85  3102   ++=
L85  3106   vmap
L85  3110   .
L85  3111   values
L85  3117   )
L85  3118   .
L85  3119   result
L85  3125   (
L85  3126   )
L86  3128   <nl>
L86  3134   vsetDefined
L86  3146   =
L86  3148   true
L87  3157   }
L88  3159   <nl>
L88  3163   vset
L89  3170   }
L92  3237   <nls>
L92  3239   protected
L92  3249   var
L92  3253   nextId
L92  3259   :
L92  3261   Int
L92  3265   =
L92  3267   initial
L95  3335   <nls>
L95  3337   protected
L95  3347   var
L95  3351   nextName
L95  3359   :
L95  3361   Iterator
L95  3369   [
L95  3370   String
L95  3376   ]
L95  3378   =
L95  3380   _
L97  3383   <nls>
L97  3385   private
L97  3393   def
L97  3397   nextNameOrNull
L97  3412   =
L98  3418   if
L98  3421   (
L98  3422   nextName
L98  3431   !=
L98  3434   null
L98  3439   &&
L98  3442   nextName
L98  3450   .
L98  3451   hasNext
L98  3458   )
L98  3460   nextName
L98  3468   .
L98  3469   next
L98  3473   (
L98  3474   )
L98  3476   else
L98  3481   null
L102 3581   <nls>
L102 3583   private
L102 3591   var
L102 3595   topId
L102 3601   =
L102 3603   initial
L106 3727   <nls>
L106 3729   private
L106 3737   var
L106 3741   bottomId
L106 3750   =
L106 3752   if
L106 3754   (
L106 3755   initial
L106 3763   <
L106 3765   0
L106 3766   )
L106 3768   initial
L106 3776   else
L106 3781   0
L110 3899   <nls>
L110 3901   final
L110 3907   def
L110 3911   maxId
L110 3917   =
L110 3919   topId
L114 3986   <nls>
L114 3988   final
L114 3994   def
L114 3998   apply
L114 4003   (
L114 4004   x
L114 4005   :
L114 4007   Int
L114 4010   )
L114 4011   :
L114 4013   Value
L114 4019   =
L114 4021   vmap
L114 4025   (
L114 4026   x
L114 4027   )
L124 4410   <nls>
L124 4412   final
L124 4418   def
L124 4422   withName
L124 4430   (
L124 4431   s
L124 4432   :
L124 4434   String
L124 4440   )
L124 4441   :
L124 4443   Value
L124 4449   =
L124 4451   values
L124 4457   .
L124 4458   find
L124 4462   (
L124 4463   _
L124 4464   .
L124 4465   toString
L124 4474   ==
L124 4477   s
L124 4478   )
L124 4479   .
L124 4480   get
L127 4543   <nls>
L127 4545   protected
L127 4555   final
L127 4561   def
L127 4565   Value
L127 4570   :
L127 4572   Value
L127 4578   =
L127 4580   Value
L127 4585   (
L127 4586   nextId
L127 4592   )
L136 4882   <nls>
L136 4884   protected
L136 4894   final
L136 4900   def
L136 4904   Value
L136 4909   (
L136 4910   i
L136 4911   :
L136 4913   Int
L136 4916   )
L136 4917   :
L136 4919   Value
L136 4925   =
L136 4927   Value
L136 4932   (
L136 4933   i
L136 4934   ,
L136 4936   nextNameOrNull
L136 4950   )
L143 5132   <nls>
L143 5134   protected
L143 5144   final
L143 5150   def
L143 5154   Value
L143 5159   (
L143 5160   name
L143 5164   :
L143 5166   String
L143 5172   )
L143 5173   :
L143 5175   Value
L143 5181   =
L143 5183   Value
L143 5188   (
L143 5189   nextId
L143 5195   ,
L143 5197   name
L143 5201   )
L153 5601   <nls>
L153 5603   protected
L153 5613   final
L153 5619   def
L153 5623   Value
L153 5628   (
L153 5629   i
L153 5630   :
L153 5632   Int
L153 5635   ,
L153 5637   name
L153 5641   :
L153 5643   String
L153 5649   )
L153 5650   :
L153 5652   Value
L153 5658   =
L153 5660   new
L153 5664   Val
L153 5667   (
L153 5668   i
L153 5669   ,
L153 5671   name
L153 5675   )
L155 5678   <nls>
L155 5680   private
L155 5688   def
L155 5692   populateNameMap
L155 5707   (
L155 5708   )
L155 5710   {
L156 5716   val
L156 5720   fields
L156 5727   =
L156 5729   getClass
L156 5737   .
L156 5738   getDeclaredFields
L157 5756   <nl>
L157 5760   def
L157 5764   isValDef
L157 5772   (
L157 5773   m
L157 5774   :
L157 5776   JMethod
L157 5783   )
L157 5785   =
L157 5787   fields
L157 5794   exists
L157 5801   (
L157 5802   fd
L157 5805   =>
L157 5808   fd
L157 5810   .
L157 5811   getName
L157 5819   ==
L157 5822   m
L157 5823   .
L157 5824   getName
L157 5832   &&
L157 5835   fd
L157 5837   .
L157 5838   getType
L157 5846   ==
L157 5849   m
L157 5850   .
L157 5851   getReturnType
L157 5864   )
L160 5948   <nls>
L160 5952   val
L160 5956   methods
L160 5964   =
L160 5966   getClass
L160 5974   .
L160 5975   getMethods
L160 5986   filter
L160 5993   (
L160 5994   m
L160 5996   =>
L160 5999   m
L160 6000   .
L160 6001   getParameterTypes
L160 6018   .
L160 6019   isEmpty
L160 6027   &&
L161 6081   classOf
L161 6088   [
L161 6089   Value
L161 6094   ]
L161 6095   .
L161 6096   isAssignableFrom
L161 6112   (
L161 6113   m
L161 6114   .
L161 6115   getReturnType
L161 6128   )
L161 6130   &&
L162 6184   m
L162 6185   .
L162 6186   getDeclaringClass
L162 6204   !=
L162 6207   classOf
L162 6214   [
L162 6215   Enumeration
L162 6226   ]
L162 6228   &&
L163 6282   isValDef
L163 6290   (
L163 6291   m
L163 6292   )
L163 6293   )
L164 6295   <nl>
L164 6299   methods
L164 6307   foreach
L164 6315   {
L164 6317   m
L164 6319   =>
L165 6328   val
L165 6332   name
L165 6337   =
L165 6339   m
L165 6340   .
L165 6341   getName
L167 6406   <nl>
L167 6412   val
L167 6416   value
L167 6422   =
L167 6424   m
L167 6425   .
L167 6426   invoke
L167 6432   (
L167 6433   this
L167 6437   )
L167 6438   .
L167 6439   asInstanceOf
L167 6451   [
L167 6452   Value
L167 6457   ]
L169 6535   <nl>
L169 6541   if
L169 6544   (
L169 6545   value
L169 6550   .
L169 6551   outerEnum
L169 6561   eq
L169 6564   thisenum
L169 6572   )
L169 6574   {
L170 6584   val
L170 6588   id
L170 6591   =
L170 6593   Int
L170 6596   .
L170 6597   unbox
L170 6602   (
L170 6603   classOf
L170 6610   [
L170 6611   Val
L170 6614   ]
L170 6616   getMethod
L170 6626   id
L170 6631   invoke
L170 6638   value
L170 6643   )
L171 6645   <nl>
L171 6653   nmap
L171 6658   +=
L171 6661   (
L171 6662   (
L171 6663   id
L171 6665   ,
L171 6667   name
L171 6671   )
L171 6672   )
L172 6680   }
L173 6686   }
L174 6690   }
L179 6823   <nls>
L179 6825   private
L179 6833   def
L179 6837   nameOf
L179 6843   (
L179 6844   i
L179 6845   :
L179 6847   Int
L179 6850   )
L179 6851   :
L179 6853   String
L179 6860   =
L179 6862   synchronized
L179 6875   {
L179 6877   nmap
L179 6881   .
L179 6882   getOrElse
L179 6891   (
L179 6892   i
L179 6893   ,
L179 6895   {
L179 6897   populateNameMap
L179 6912   (
L179 6913   )
L179 6915   ;
L179 6917   nmap
L179 6921   (
L179 6922   i
L179 6923   )
L179 6925   }
L179 6926   )
L179 6928   }
L182 6975   <nls>
L182 6977   @
L182 6978   SerialVersionUID
L182 6994   (
L182 6995   7091335633555234129
L182 7015   )
L183 7017   <nl>
L183 7019   abstract
L183 7028   class
L183 7034   Value
L183 7040   extends
L183 7048   Ordered
L183 7055   [
L183 7056   Value
L183 7061   ]
L183 7063   with
L183 7068   Serializable
L183 7081   {
L185 7148   def
L185 7152   id
L185 7154   :
L185 7156   Int
L187 7251   <nl>
L187 7255   private
L187 7262   [
L187 7263   Enumeration
L187 7274   ]
L187 7276   val
L187 7280   outerEnum
L187 7290   =
L187 7292   thisenum
L189 7302   <nls>
L189 7306   override
L189 7315   def
L189 7319   compare
L189 7326   (
L189 7327   that
L189 7331   :
L189 7333   Value
L189 7338   )
L189 7339   :
L189 7341   Int
L189 7345   =
L190 7353   if
L190 7356   (
L190 7357   this
L190 7361   .
L190 7362   id
L190 7365   <
L190 7367   that
L190 7371   .
L190 7372   id
L190 7374   )
L190 7376   -
L190 7377   1
L191 7385   else
L191 7390   if
L191 7393   (
L191 7394   this
L191 7398   .
L191 7399   id
L191 7402   ==
L191 7405   that
L191 7409   .
L191 7410   id
L191 7412   )
L191 7414   0
L192 7422   else
L192 7427   1
L193 7429   <nl>
L193 7433   override
L193 7442   def
L193 7446   equals
L193 7452   (
L193 7453   other
L193 7458   :
L193 7460   Any
L193 7463   )
L193 7465   =
L193 7467   other
L193 7473   match
L193 7479   {
L194 7487   case
L194 7492   that
L194 7496   :
L194 7498   Enumeration
L194 7509   #
L194 7510   Value
L194 7517   =>
L194 7520   (
L194 7521   outerEnum
L194 7531   eq
L194 7534   that
L194 7538   .
L194 7539   outerEnum
L194 7548   )
L194 7550   &&
L194 7553   (
L194 7554   id
L194 7557   ==
L194 7560   that
L194 7564   .
L194 7565   id
L194 7567   )
L195 7569   <nl>
L195 7575   case
L195 7580   _
L195 7605   =>
L195 7608   false
L196 7618   }
L197 7620   <nl>
L197 7624   override
L197 7633   def
L197 7637   hashCode
L197 7645   :
L197 7647   Int
L197 7651   =
L197 7653   id
L197 7655   .
L197 7656   ##
L200 7731   <nls>
L200 7735   def
L200 7739   +
L200 7741   (
L200 7742   v
L200 7743   :
L200 7745   Value
L200 7750   )
L200 7752   =
L200 7754   ValueSet
L200 7762   (
L200 7763   this
L200 7767   ,
L200 7769   v
L200 7770   )
L201 7774   }
L207 7962   <nls>
L207 7964   @
L207 7965   SerialVersionUID
L207 7981   (
L207 7982   0
L207 7984   -
L207 7986   3501153230598116017
L207 8006   )
L208 8008   <nl>
L208 8010   protected
L208 8020   class
L208 8026   Val
L208 8029   (
L208 8030   i
L208 8031   :
L208 8033   Int
L208 8036   ,
L208 8038   name
L208 8042   :
L208 8044   String
L208 8050   )
L208 8052   extends
L208 8060   Value
L208 8066   with
L208 8071   Serializable
L208 8084   {
L209 8090   def
L209 8094   this
L209 8098   (
L209 8099   i
L209 8100   :
L209 8102   Int
L209 8105   )
L209 8113   =
L209 8115   this
L209 8119   (
L209 8120   i
L209 8121   ,
L209 8123   nextNameOrNull
L209 8137   )
L210 8139   <nl>
L210 8143   def
L210 8147   this
L210 8151   (
L210 8152   name
L210 8156   :
L210 8158   String
L210 8164   )
L210 8166   =
L210 8168   this
L210 8172   (
L210 8173   nextId
L210 8179   ,
L210 8181   name
L210 8185   )
L211 8187   <nl>
L211 8191   def
L211 8195   this
L211 8199   (
L211 8200   )
L211 8214   =
L211 8216   this
L211 8220   (
L211 8221   nextId
L211 8227   )
L213 8230   <nls>
L213 8234   assert
L213 8240   (
L213 8241   !
L213 8242   vmap
L213 8246   .
L213 8247   isDefinedAt
L213 8258   (
L213 8259   i
L213 8260   )
L213 8261   ,
L213 8263   Duplicate id:
L213 8280   +
L213 8282   i
L213 8283   )
L214 8285   <nl>
L214 8289   vmap
L214 8293   (
L214 8294   i
L214 8295   )
L214 8297   =
L214 8299   this
L215 8304   <nl>
L215 8308   vsetDefined
L215 8320   =
L215 8322   false
L216 8328   <nl>
L216 8332   nextId
L216 8339   =
L216 8341   i
L216 8343   +
L216 8345   1
L217 8347   <nl>
L217 8351   if
L217 8354   (
L217 8355   nextId
L217 8362   >
L217 8364   topId
L217 8369   )
L217 8371   topId
L217 8377   =
L217 8379   nextId
L218 8386   <nl>
L218 8390   if
L218 8393   (
L218 8394   i
L218 8396   <
L218 8398   bottomId
L218 8406   )
L218 8408   bottomId
L218 8417   =
L218 8419   i
L219 8421   <nl>
L219 8425   def
L219 8429   id
L219 8432   =
L219 8434   i
L220 8436   <nl>
L220 8440   override
L220 8449   def
L220 8453   toString
L220 8461   (
L220 8462   )
L220 8464   =
L221 8472   if
L221 8475   (
L221 8476   name
L221 8481   !=
L221 8484   null
L221 8488   )
L221 8490   name
L222 8501   else
L222 8506   try
L222 8510   thisenum
L222 8518   .
L222 8519   nameOf
L222 8525   (
L222 8526   i
L222 8527   )
L223 8535   catch
L223 8541   {
L223 8543   case
L223 8548   _
L223 8549   :
L223 8551   NoSuchElementException
L223 8574   =>
L223 8577   <Invalid enum: no field for #
L223 8609   +
L223 8611   i
L223 8613   +
L223 8615   >
L223 8619   }
L225 8622   <nls>
L225 8626   protected
L225 8636   def
L225 8640   readResolve
L225 8651   (
L225 8652   )
L225 8653   :
L225 8655   AnyRef
L225 8662   =
L225 8664   {
L226 8672   val
L226 8676   enum
L226 8681   =
L226 8683   thisenum
L226 8691   .
L226 8692   readResolve
L226 8703   (
L226 8704   )
L226 8705   .
L226 8706   asInstanceOf
L226 8718   [
L226 8719   Enumeration
L226 8730   ]
L227 8732   <nl>
L227 8738   if
L227 8741   (
L227 8742   enum
L227 8746   .
L227 8747   vmap
L227 8752   ==
L227 8755   null
L227 8759   )
L227 8761   this
L228 8772   else
L228 8777   enum
L228 8781   .
L228 8782   vmap
L228 8786   (
L228 8787   i
L228 8788   )
L229 8794   }
L230 8798   }
L233 8851   <nls>
L233 8853   object
L233 8860   ValueOrdering
L233 8874   extends
L233 8882   Ordering
L233 8890   [
L233 8891   Value
L233 8896   ]
L233 8898   {
L234 8904   def
L234 8908   compare
L234 8915   (
L234 8916   x
L234 8917   :
L234 8919   Value
L234 8924   ,
L234 8926   y
L234 8927   :
L234 8929   Value
L234 8934   )
L234 8935   :
L234 8937   Int
L234 8941   =
L234 8943   x
L234 8945   compare
L234 8953   y
L235 8957   }
L243 9229   <nls>
L243 9231   class
L243 9237   ValueSet
L243 9246   private
L243 9253   [
L243 9254   ValueSet
L243 9262   ]
L243 9264   (
L243 9265   private
L243 9272   [
L243 9273   this
L243 9277   ]
L243 9279   var
L243 9283   nnIds
L243 9288   :
L243 9290   immutable
L243 9299   .
L243 9300   BitSet
L243 9306   )
L244 9310   extends
L244 9318   AbstractSet
L244 9329   [
L244 9330   Value
L244 9335   ]
L245 9342   with
L245 9347   immutable
L245 9356   .
L245 9357   SortedSet
L245 9366   [
L245 9367   Value
L245 9372   ]
L246 9379   with
L246 9384   SortedSetLike
L246 9397   [
L246 9398   Value
L246 9403   ,
L246 9405   ValueSet
L246 9413   ]
L247 9420   with
L247 9425   Serializable
L247 9438   {
L249 9445   implicit
L249 9454   def
L249 9458   ordering
L249 9466   :
L249 9468   Ordering
L249 9476   [
L249 9477   Value
L249 9482   ]
L249 9484   =
L249 9486   ValueOrdering
L250 9500   <nl>
L250 9504   def
L250 9508   rangeImpl
L250 9517   (
L250 9518   from
L250 9522   :
L250 9524   Option
L250 9530   [
L250 9531   Value
L250 9536   ]
L250 9537   ,
L250 9539   until
L250 9544   :
L250 9546   Option
L250 9552   [
L250 9553   Value
L250 9558   ]
L250 9559   )
L250 9560   :
L250 9562   ValueSet
L250 9571   =
L251 9579   new
L251 9583   ValueSet
L251 9591   (
L251 9592   nnIds
L251 9597   .
L251 9598   rangeImpl
L251 9607   (
L251 9608   from
L251 9612   .
L251 9613   map
L251 9616   (
L251 9617   _
L251 9618   .
L251 9619   id
L251 9622   -
L251 9624   bottomId
L251 9632   )
L251 9633   ,
L251 9635   until
L251 9640   .
L251 9641   map
L251 9644   (
L251 9645   _
L251 9646   .
L251 9647   id
L251 9650   -
L251 9652   bottomId
L251 9660   )
L251 9661   )
L251 9662   )
L253 9665   <nls>
L253 9669   override
L253 9678   def
L253 9682   empty
L253 9688   =
L253 9690   ValueSet
L253 9698   .
L253 9699   empty
L254 9705   <nl>
L254 9709   def
L254 9713   contains
L254 9721   (
L254 9722   v
L254 9723   :
L254 9725   Value
L254 9730   )
L254 9732   =
L254 9734   nnIds
L254 9740   contains
L254 9749   (
L254 9750   v
L254 9751   .
L254 9752   id
L254 9755   -
L254 9757   bottomId
L254 9765   )
L255 9767   <nl>
L255 9771   def
L255 9775   +
L255 9777   (
L255 9778   value
L255 9783   :
L255 9785   Value
L255 9790   )
L255 9792   =
L255 9794   new
L255 9798   ValueSet
L255 9806   (
L255 9807   nnIds
L255 9813   +
L255 9815   (
L255 9816   value
L255 9821   .
L255 9822   id
L255 9825   -
L255 9827   bottomId
L255 9835   )
L255 9836   )
L256 9838   <nl>
L256 9842   def
L256 9846   -
L256 9848   (
L256 9849   value
L256 9854   :
L256 9856   Value
L256 9861   )
L256 9863   =
L256 9865   new
L256 9869   ValueSet
L256 9877   (
L256 9878   nnIds
L256 9884   -
L256 9886   (
L256 9887   value
L256 9892   .
L256 9893   id
L256 9896   -
L256 9898   bottomId
L256 9906   )
L256 9907   )
L257 9909   <nl>
L257 9913   def
L257 9917   iterator
L257 9926   =
L257 9928   nnIds
L257 9933   .
L257 9934   iterator
L257 9943   map
L257 9947   (
L257 9948   id
L257 9951   =>
L257 9954   thisenum
L257 9962   .
L257 9963   apply
L257 9968   (
L257 9969   bottomId
L257 9978   +
L257 9980   id
L257 9982   )
L257 9983   )
L258 9985   <nl>
L258 9989   override
L258 9998   def
L258 10002  keysIteratorFrom
L258 10018  (
L258 10019  start
L258 10024  :
L258 10026  Value
L258 10031  )
L258 10033  =
L258 10035  nnIds
L258 10041  keysIteratorFrom
L258 10058  start
L258 10063  .
L258 10064  id
L258 10068  map
L258 10072  (
L258 10073  id
L258 10076  =>
L258 10079  thisenum
L258 10087  .
L258 10088  apply
L258 10093  (
L258 10094  bottomId
L258 10103  +
L258 10105  id
L258 10107  )
L258 10108  )
L259 10110  <nl>
L259 10114  override
L259 10123  def
L259 10127  stringPrefix
L259 10140  =
L259 10142  thisenum
L259 10151  +
L259 10153  .ValueSet
L262 10265  <nl>
L262 10269  def
L262 10273  toBitMask
L262 10282  :
L262 10284  Array
L262 10289  [
L262 10290  Long
L262 10294  ]
L262 10296  =
L262 10298  nnIds
L262 10303  .
L262 10304  toBitMask
L263 10316  }
L266 10360  <nls>
L266 10362  object
L266 10369  ValueSet
L266 10378  {
L267 10384  import
L267 10391  generic
L267 10398  .
L267 10399  CanBuildFrom
L270 10444  <nls>
L270 10448  val
L270 10452  empty
L270 10458  =
L270 10460  new
L270 10464  ValueSet
L270 10472  (
L270 10473  immutable
L270 10482  .
L270 10483  BitSet
L270 10489  .
L270 10490  empty
L270 10495  )
L272 10549  <nl>
L272 10553  def
L272 10557  apply
L272 10562  (
L272 10563  elems
L272 10568  :
L272 10570  Value
L272 10575  *
L272 10576  )
L272 10577  :
L272 10579  ValueSet
L272 10588  =
L272 10590  (
L272 10591  newBuilder
L272 10602  ++=
L272 10606  elems
L272 10611  )
L272 10612  .
L272 10613  result
L272 10619  (
L272 10620  )
L275 10743  <nl>
L275 10747  def
L275 10751  fromBitMask
L275 10762  (
L275 10763  elems
L275 10768  :
L275 10770  Array
L275 10775  [
L275 10776  Long
L275 10780  ]
L275 10781  )
L275 10782  :
L275 10784  ValueSet
L275 10793  =
L275 10795  new
L275 10799  ValueSet
L275 10807  (
L275 10808  immutable
L275 10817  .
L275 10818  BitSet
L275 10824  .
L275 10825  fromBitMask
L275 10836  (
L275 10837  elems
L275 10842  )
L275 10843  )
L277 10888  <nl>
L277 10892  def
L277 10896  newBuilder
L277 10906  :
L277 10908  mutable
L277 10915  .
L277 10916  Builder
L277 10923  [
L277 10924  Value
L277 10929  ,
L277 10931  ValueSet
L277 10939  ]
L277 10941  =
L277 10943  new
L277 10947  mutable
L277 10954  .
L277 10955  Builder
L277 10962  [
L277 10963  Value
L277 10968  ,
L277 10970  ValueSet
L277 10978  ]
L277 10980  {
L278 10988  private
L278 10995  [
L278 10996  this
L278 11000  ]
L278 11002  val
L278 11006  b
L278 11008  =
L278 11010  new
L278 11014  mutable
L278 11021  .
L278 11022  BitSet
L279 11029  <nl>
L279 11035  def
L279 11039  +=
L279 11042  (
L279 11043  x
L279 11044  :
L279 11046  Value
L279 11051  )
L279 11053  =
L279 11055  {
L279 11057  b
L279 11059  +=
L279 11062  (
L279 11063  x
L279 11064  .
L279 11065  id
L279 11068  -
L279 11070  bottomId
L279 11078  )
L279 11079  ;
L279 11081  this
L279 11086  }
L280 11088  <nl>
L280 11094  def
L280 11098  clear
L280 11103  (
L280 11104  )
L280 11106  =
L280 11108  b
L280 11109  .
L280 11110  clear
L280 11115  (
L280 11116  )
L281 11118  <nl>
L281 11124  def
L281 11128  result
L281 11134  (
L281 11135  )
L281 11137  =
L281 11139  new
L281 11143  ValueSet
L281 11151  (
L281 11152  b
L281 11153  .
L281 11154  toImmutable
L281 11165  )
L282 11171  }
L284 11220  <nl>
L284 11224  implicit
L284 11233  def
L284 11237  canBuildFrom
L284 11249  :
L284 11251  CanBuildFrom
L284 11263  [
L284 11264  ValueSet
L284 11272  ,
L284 11274  Value
L284 11279  ,
L284 11281  ValueSet
L284 11289  ]
L284 11291  =
L285 11299  new
L285 11303  CanBuildFrom
L285 11315  [
L285 11316  ValueSet
L285 11324  ,
L285 11326  Value
L285 11331  ,
L285 11333  ValueSet
L285 11341  ]
L285 11343  {
L286 11353  def
L286 11357  apply
L286 11362  (
L286 11363  from
L286 11367  :
L286 11369  ValueSet
L286 11377  )
L286 11379  =
L286 11381  newBuilder
L287 11392  <nl>
L287 11400  def
L287 11404  apply
L287 11409  (
L287 11410  )
L287 11412  =
L287 11414  newBuilder
L288 11431  }
L289 11435  }
L290 11437  }
L290 11438  eof
